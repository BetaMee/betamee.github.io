{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/content/react-7a5cb332641658088673b53331b091b0","result":{"data":{"site":{"siteMetadata":{"author":"橡树上","title":"十二棵橡树"}},"markdownRemark":{"id":"0847344e-d889-5af0-a671-54a571ae2268","html":"<h2 id=\"目录\" style=\"position:relative;\"><a href=\"#%E7%9B%AE%E5%BD%95\" aria-label=\"目录 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>目录</h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3\">函数参数详解</a></li>\n<li><a href=\"#%E4%B8%A4%E4%B8%AA-hook-%E7%9A%84%E5%8C%BA%E5%88%AB\">两个 hook 的区别</a></li>\n<li><a href=\"#%E6%9B%BF%E4%BB%A3-class-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0\">替代 class 的生命周期函数</a></li>\n<li><a href=\"#effect-%E4%B8%AD%E4%BD%BF%E7%94%A8-props-%E5%92%8C-state-%E7%9A%84%E9%99%B7%E9%98%B1\">effect 中使用 props 和 state 的陷阱</a></li>\n<li><a href=\"#%E5%85%B3%E4%BA%8E-Hooks-%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83\">关于 Hooks 的一点思考</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"函数参数详解\" style=\"position:relative;\"><a href=\"#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3\" aria-label=\"函数参数详解 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>函数参数详解</h2>\n<p>两个 effect hook 是 React 提供给用户处理<strong>副作用逻辑</strong>的一个窗口，比如改变 DOM、添加订阅、设置定时器、记录日志以及执行其他各种渲染过程中不允许出现的操作。</p>\n<p>在使用上，两个 hook 的函数签名是一样的:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 执行一些副作用</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 清理函数</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这样会每次组件更新后都会执行，有点类似于 componentDidUpdate，但请不要用 class 组件的生命周期思维方式来看待 hooks，只是看起来可以先这么理解。如果想要像 componentDidMount 那样只执行一次的话，第二个参数传入空数组：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 执行一些副作用</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 清理函数</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>但有的时候需要根据 props 的变化来条件执行 effect 函数，要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> subscription <span class=\"token operator\">=</span> props<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">.</span><span class=\"token function\">subscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      subscription<span class=\"token punctuation\">.</span><span class=\"token function\">unsubscribe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span>props<span class=\"token punctuation\">.</span>source<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>此时，只有当 <code>props.source</code> 改变后才会重新创建订阅。</p>\n<h2 id=\"两个-hook-的区别\" style=\"position:relative;\"><a href=\"#%E4%B8%A4%E4%B8%AA-hook-%E7%9A%84%E5%8C%BA%E5%88%AB\" aria-label=\"两个 hook 的区别 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>两个 hook 的区别</h2>\n<p>这里就要说到 useEffect 和 useLayoutEffect 区别了。</p>\n<p>官网中的提示，绝大部分场景只用到 useEffect 就可以，只有当它出问题的时候再尝试使用 useLayoutEffect。</p>\n<p>但什么样的情况下 useLayoutEffect 才能体现不同之处呢？</p>\n<p>首先我们知道，浏览器中 JS 线程和渲染线程（注意是线程）是互斥的，对于 React 的函数组件来说，其更新过程大致分为以下步骤：</p>\n<p>（这里假设 React 组件已初次渲染成功）</p>\n<ol>\n<li>用户点击事件，改变了某一个state</li>\n<li>React 内部更新 state 变量</li>\n<li>React 处理更新组件中 return 出来的 DOM 节点（进行一系列 diff 调度等流程）</li>\n<li>将更新过后的 DOM 数据绘制到浏览器中</li>\n<li>用户看到新的页面</li>\n</ol>\n<p>前三步都是 React 在处理，也就是 JS 线程执行我们所写的代码，都是在内存中进行一系列操作，而第四步才是真正将更新后数据交给渲染线程进行处理。</p>\n<p>那这时候的 useEffect 只会在第四步后才会调用，也就是在浏览器绘制完后才调用，而且 useEffect 还是异步执行的，所谓的异步就是被 React 使用 requestIdleCallback 封装的，只在浏览器空闲时候才会执行，这就保证了不会阻塞浏览器的渲染过程。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 411px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABwUlEQVQoz22QWXPaUAxG+f//oA99zTBdIUkpMBQDoZA2LGanaWhTAgMEQrxD7Ht9aoyBPlR3zkijK30jKWZsdY5stACdnQ0GA4rFIrVajfF4HOZ830O8rEEae3wT331Gelb07xNrTVRaU5X2tBWhshEO7VabvJKnWq3SqNeRPnjODF+rsrrPsRhlmN+l2T5eBbodpJShaKw6rJAsJkkUPqKoeXqLLvOnGavlisViETFHNywmv5tg3dC+jlNIveJr9jXGVAG7ixTeXvDH44ADw0Wf4byH82LzP/PdNVKv465rGLMKm+V3fKOBMIfhuuHKnvTwAnUhBQIZPH/f/C9h8d5L4YZZy9LQ9TW2bURVe4sdIxHI2XaEFSJME7ndRuOdmnahuxW4G8H4foJjbhCuHyCJ+VGh8zBGLylY1xW0cgmjUsYKvN0P7hNNeTj803zNTb5F86oX0ih1Uct9vmXUk6D5a8TwIsltOkXj/Ts65wnuPqe4zedYLpeYwbS6pmM7Fn9GDyTOPvHh7JzLtxku3qRJxC/JxAsnwe10gpbLogUCurLjC8/ZdDBh77jnodbSHBpKj7rSDX2z2KeW79At/+QvHEmakUJTHUcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"d8cc4ac0.png\"\n        title=\"d8cc4ac0.png\"\n        src=\"/static/01e3efb0174c7b859776baa17a1cd2b6/2a432/d8cc4ac0.png\"\n        srcset=\"/static/01e3efb0174c7b859776baa17a1cd2b6/63868/d8cc4ac0.png 250w,\n/static/01e3efb0174c7b859776baa17a1cd2b6/2a432/d8cc4ac0.png 411w\"\n        sizes=\"(max-width: 411px) 100vw, 411px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>而 useLayoutEffect 就不一样，它会在第三第四步之间执行，而且是同步阻塞后面的流程。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 501px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABkklEQVQoz02RbXMSMRSF+f+/w6kv4zi10g86baWr1LaAsMJSESpV9oVlWWBhy26y2TwGGLVn5uQmuTcnJ7mV2WbKjvPHiPk2IkpDwnWAUDmO42BZFrZtU6gSVIrOXJBTEMGB0qfMQ7Q2eYNK22vRcdtc2Oecd864/XmD7bdx4wmj4Yher8c3Ixgv1qTzPsnkPd73KsHwlODHKf6gioyv0aVA7wSdaZd+0KN53+B2eE3XtXGCLnEacYDej6UJMv3FdvaZxcQi8T6xCeqsPAu57BhBaVwaQVHk5EWGNBsFCqELcnNbyX/ov1Ero5yZmURkK0SeUIi1WYt/tZUn55BhSOF5qCCg8D2k55IbotTTMpJ4yzJMmfsJ44HLJs5JopTFNKGijc+dA60KZld1GkfPaL44wn79itbL53hnH1hOJuRSkmVb0k3K77sA++qO5qXNzUWbRs2m3xji1EcHwf0flYrHdouHk2OGx28YV08Yv3vLyqqxmc1MlxVSCvNMwUPPp3PZp/mxu+fXmmlcfUD/yz1/AIRJBzcMuqgqAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"c6848f5a.png\"\n        title=\"c6848f5a.png\"\n        src=\"/static/77fe1070cc564c03e19d3f742a570fdd/55811/c6848f5a.png\"\n        srcset=\"/static/77fe1070cc564c03e19d3f742a570fdd/63868/c6848f5a.png 250w,\n/static/77fe1070cc564c03e19d3f742a570fdd/0b533/c6848f5a.png 500w,\n/static/77fe1070cc564c03e19d3f742a570fdd/55811/c6848f5a.png 501w\"\n        sizes=\"(max-width: 501px) 100vw, 501px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>这两者的差距会在某些 DOM 变化的场景下体现出来：</p>\n<p>以下面的代码举例：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">FuncCom</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>counter<span class=\"token punctuation\">,</span> setCounter<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>counter <span class=\"token operator\">===</span> <span class=\"token number\">12</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 为了演示，这里同步设置一个延时函数 500ms</span>\n            <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token function\">setCounter</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">style</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n            fontSize<span class=\"token operator\">:</span> <span class=\"token string\">'100px'</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">setCounter</span><span class=\"token punctuation\">(</span><span class=\"token number\">12</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>counter<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n        </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以观察到，初始屏幕上是 0，当点击触发 <code>setCounter</code> 后，屏幕上先是出现了 12，最后变为了 2:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.599999999999998%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvUlEQVQY032Q3Q6DMAiF+/7vOC+9MPa/VeusjMPC4kw2EgI5H9Cj5jxP0tAW2lW/xz9maq3kvCcfAqWcKYRIpVRq20a5FHLOUYyJYkpSC88/951ZZuYpxPhmnLglBwsvzrOVgcxHoa3rKhUL0zRJVdZakx0c8Z6NcFVmNnaCsNaygyg9FqDv7KTz5z2GQYbRQwcHQ4zjSMdxyG8AM3gJbnRwWZYvh9A1lWHuFzO9d9LES9rjxY920ZVBvyfYC/ee0/x46PQIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"56276b0b.png\"\n        title=\"56276b0b.png\"\n        src=\"/static/538f934c421297d43c28638c2bc9e506/00d43/56276b0b.png\"\n        srcset=\"/static/538f934c421297d43c28638c2bc9e506/63868/56276b0b.png 250w,\n/static/538f934c421297d43c28638c2bc9e506/0b533/56276b0b.png 500w,\n/static/538f934c421297d43c28638c2bc9e506/00d43/56276b0b.png 1000w,\n/static/538f934c421297d43c28638c2bc9e506/aa440/56276b0b.png 1500w,\n/static/538f934c421297d43c28638c2bc9e506/e8950/56276b0b.png 2000w,\n/static/538f934c421297d43c28638c2bc9e506/aea0a/56276b0b.png 2018w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>想象一下，这就是有些动画场景会出现的<strong>闪屏</strong>现象，原因在于 useEffect 执行的时候 <code>setCounter(12)</code> 已经触发一次渲染了。这在体验上很不好。</p>\n<p>换成了 useLayoutEffect 后，屏幕上只会出现 0 和 2，这是因为 useLayoutEffect 的同步特性，会在浏览器渲染之前<strong>同步更新 DOM 数据</strong>，哪怕是多次的操作，也会在渲染前一次性处理完，再交给浏览器绘制。这样不会导致<strong>闪屏</strong>现象发生。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA00lEQVQY022RCw6CMBBEvf/lOAAXQGmLQP98xp0NNUZtMmGbnb79cDvPE9u2odaKmBJCiMiloMi9lKpxrZt6qJwzfAhIKWuePvWLjuPAjcAYI+ZlwTgaDPcH3PSEMRbWOoknKRIUtPoV1jkMw6BfajQGk/if86wFFZikM0L5cF3lkbXw3quCdpMU2DyUE9giEC9FeI+iN5BmtszDZNd1GjNXrnGaZ993zfV9j1mAPFwX83+B3AM7anGDfQPZbYt/gEl/RlBTG+9zDYwJax7q2xOukV/iotJLFTp2lQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"181e0464.png\"\n        title=\"181e0464.png\"\n        src=\"/static/0948d7165ae8d1725de14e62d115d46e/00d43/181e0464.png\"\n        srcset=\"/static/0948d7165ae8d1725de14e62d115d46e/63868/181e0464.png 250w,\n/static/0948d7165ae8d1725de14e62d115d46e/0b533/181e0464.png 500w,\n/static/0948d7165ae8d1725de14e62d115d46e/00d43/181e0464.png 1000w,\n/static/0948d7165ae8d1725de14e62d115d46e/aa440/181e0464.png 1500w,\n/static/0948d7165ae8d1725de14e62d115d46e/de766/181e0464.png 1838w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>这里简单总结一下：</p>\n<ul>\n<li>useEffect 是异步非阻塞调用</li>\n<li>useLayoutEffect 是同步阻塞调用</li>\n<li>useEffect 浏览器绘制后</li>\n<li>useLayoutEffect 在 DOM 变更（React 的更新）后，浏览器绘制前完成所有操作</li>\n</ul>\n<h2 id=\"替代-class-的生命周期函数\" style=\"position:relative;\"><a href=\"#%E6%9B%BF%E4%BB%A3-class-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0\" aria-label=\"替代 class 的生命周期函数 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>替代 class 的生命周期函数</h2>\n<p>进一步分析，我们希望在函数组件中使用 hook 函数替换 class 组件中的生命周期，那么这里是如何对应的？</p>\n<p>同样举一个 class 组件的例子：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ClassCom</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">React<span class=\"token punctuation\">.</span>Component</span> <span class=\"token punctuation\">{</span>\n    state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n        value<span class=\"token operator\">:</span> <span class=\"token string\">'a'</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 延时触发</span>\n        <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n            value<span class=\"token operator\">:</span> <span class=\"token string\">'fasd'</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">componentDidUpdate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>value <span class=\"token operator\">===</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">// 延时触发</span>\n            <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n                value<span class=\"token operator\">:</span> <span class=\"token string\">'c'</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n            <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span>\n                <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n                    value<span class=\"token operator\">:</span> <span class=\"token string\">'b'</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span></span>\n            <span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n                Class Components </span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>value<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token plain-text\">\n            </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在浏览器中，初次渲染用户不会看到 <em>Class Components a</em> 这个值，而是直接出现 mount 状态之后的值 <em>Class Components fasd</em>，当触发点击事件后，只会显示 didupdate 之后的值 <em>Class Components c</em>。</p>\n<p>这说明了 componentDidMount 和 componentDidUpdate 都是同步阻塞的，而且是在 React 提交给浏览器渲染步骤之前。</p>\n<p>所以从表现（以及源码中的流程）来看，useLayoutEffect 和 componentDidMount，componentDidUpdate 调用时机是一致的，且都是被 React 同步调用，都会阻塞浏览器渲染。</p>\n<p>同上，useLayoutEffect 返回的 clean 函数的调用位置、时机与 componentWillUnmount 一致，且都是同步调用。useEffect 的 clean 函数从调用时机上来看，更像是 componentDidUnmount (尽管 React 中并没有这个生命周期函数)。</p>\n<p>虽然 useLayoutEffect 更像 class 中的生命周期函数，但官方的建议是大多数正常情况下，并不需要使用它，而是使用 useEffect，因为 useEffect 不会阻塞渲染，只有在涉及到<strong>修改 DOM、动画等场景下</strong>考虑使用 useLayoutEffect，所有的修改会一次性更新到浏览器中，减少用户体验上的不适。</p>\n<h2 id=\"effect-中使用-props-和-state-的陷阱\" style=\"position:relative;\"><a href=\"#effect-%E4%B8%AD%E4%BD%BF%E7%94%A8-props-%E5%92%8C-state-%E7%9A%84%E9%99%B7%E9%98%B1\" aria-label=\"effect 中使用 props 和 state 的陷阱 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>effect 中使用 props 和 state 的陷阱</h2>\n<p>在使用 effect 的过程中，有一个隐形的 bug 要注意。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Counter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>count<span class=\"token punctuation\">,</span> setCount<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span>count<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>这段代码的意图很简单，每隔 1000ms 更新 <em>count</em>，但事实上，count 永远只会增加到 1！</p>\n<p>同样的代码用 class 组件来实现，就不会有这个问题：</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Counter</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Components</span> <span class=\"token punctuation\">{</span>\n  state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    count<span class=\"token operator\">:</span> <span class=\"token number\">0</span>\n  <span class=\"token punctuation\">}</span>\n  id <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        count<span class=\"token operator\">:</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentWillUnmount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h1</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">{</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h1</span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>上面 class 组件和函数组件的代码的差异在于，class 组件中的 <em>this.state</em> 是可变的！每一次的更新都是对 state 对象的一个更新，一次又一次的 setInterval 中引用的都会是新 state 中的值。这在使用 class 组件中很常见，我们对于 state 对象也是这么期待的。</p>\n<p>然而在函数组件中情况就不一样了。函数组件由于每次更新都会经历重新调用的过程，<em>useEffect(callback)</em> 中的回调函数都是全新的，这样其中引用到的 state 值将只跟当次渲染绑定。这是很神奇吗？不，这就是闭包！这只是 JavaScript 的语言特性而已。</p>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 回调函数只运行一次，这里的 count 只记住初次渲染的那个值</span>\n    <span class=\"token comment\">// 所以导致每一次的 setInterval 中用到的永远都不会变！</span>\n    <span class=\"token keyword\">const</span> id <span class=\"token operator\">=</span> <span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">setCount</span><span class=\"token punctuation\">(</span>count <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token function\">clearInterval</span><span class=\"token punctuation\">(</span>id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这点在使用函数组件要小心，写惯了 class 组件后，我们对于变量的一些使用上很容易产生误解。把函数组件当成纯粹的函数，每一次的组件更新渲染当前的页面，也会记住当前环境下的变量值。这就是 React Hooks 所推崇的<strong>逻辑和状态的同步</strong>，这跟 class 组件以<strong>生命周期</strong>为划分的思维有着令人迷惑的差距，虽然同是 React，但这是全新的一个思维方式，甚至我觉得更接近 JavaScript 语言的本质，更有函数式的气质。</p>\n<p>要想解决这个 setInterval 带来的困惑，可以深入看一下这篇 post: <a href=\"https://overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/\">Making setInterval Declarative with React Hooks</a></p>\n<p>解决方案很简单，但解决思考的过程很惊奇。</p>\n<h2 id=\"关于-hooks-的一点思考\" style=\"position:relative;\"><a href=\"#%E5%85%B3%E4%BA%8E-hooks-%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83\" aria-label=\"关于 hooks 的一点思考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>关于 Hooks 的一点思考</h2>\n<p>React 从刚推出来的时候就宣扬<strong>单向数据流</strong>的特点，根据 <em>state</em> 和 <em>props</em> 对象的变化来更新组件，这带来了前端的一次革命，让开发者摆脱了 jquery 这样命令式的思维编程方式，拥抱声明式编程。</p>\n<p>但经典的 calss 组件也不是没有问题，复杂难懂的<strong>生命周期 API</strong>将我们的<strong>状态逻辑</strong>拆分到各个阶段，这就给我们设计组件多了一个时间维度思考。</p>\n<p>而 Hooks 是进一步的革命，彻底抛弃<strong>时间</strong>这一思考负重，从思考“我的状态逻辑应该放在组件哪些生命周期中”到思考“随着状态变化，我的页面应该展示成什么样” 和 “随着状态变化，什么样的副作用应该被触发”。</p>\n<p>这种“逻辑状态和与页面的同步”才是真正的 React 数据流思维方式，这是一种巨大的思维减负。</p>\n<p>useEffect 和 useLayoutEffect 相对于 componentDidMount 这样的 API 来说，尽管可以替代模仿，但本质上是不同的。 对于 effect hook API，我们思考的是* UI 状态完成后，我们需要做一些什么的副作用操作* ？而在 componentMount API 中我们思考的是<em>这个时间阶段中我们可以做些什么副作用操作</em>？</p>\n<p>componentMount API 思考的是各个时间阶段中的操作，effect hook API 不需要考虑时间这一因素，只需要考虑组件状态变化后的处理。</p>\n<h2 id=\"参考\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考</h2>\n<ul>\n<li>[1] <a href=\"https://overreacted.io/how-are-function-components-different-from-classes/\">How Are Function Components Different from Classes? — Overreacted</a></li>\n<li>[2] <a href=\"https://overreacted.io/a-complete-guide-to-useeffect/\">A Complete Guide to useEffect — Overreacted</a></li>\n<li>[3] <a href=\"https://overreacted.io/making-setinterval-declarative-with-react-hooks/\">Making setInterval Declarative with React Hooks — Overreacted</a></li>\n<li>[4] <a href=\"https://daveceddia.com/useeffect-vs-uselayouteffect/\">When to useLayoutEffect Instead of useEffect (example)</a></li>\n<li>[5] <a href=\"https://blog.csdn.net/hsany330/article/details/106143592\">useEffect和useLayoutEffect的区别<em>hsany330的专栏-CSDN博客</em>uselayouteffect</a></li>\n<li>[6] <a href=\"https://blog.logrocket.com/useeffect-vs-uselayouteffect/\">useEffect vs. useLayoutEffect in plain, approachable language</a></li>\n<li>[7] <a href=\"https://reacttraining.com/blog/useEffect-is-not-the-new-componentDidMount/\">React Training: useEffect(fn, []) is not the new componentDidMount()</a></li>\n</ul>","frontmatter":{"title":"解析 useEffect 和 useLayoutEffect","category":"React","tags":"Hooks","date":"2020-08-19","uninqueid":"7a5cb332641658088673b53331b091b0"}}},"pageContext":{"uninqueid":"7a5cb332641658088673b53331b091b0"}},"staticQueryHashes":["3649515864"]}