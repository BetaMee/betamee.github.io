{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/content/Node-Node 异步编程探究/","result":{"data":{"site":{"siteMetadata":{"author":"橡树上","title":"十二棵橡树"}},"markdownRemark":{"id":"e9cfe015-79c0-5338-aceb-53ca842729e6","html":"<h2 id=\"目录\" style=\"position:relative;\"><a href=\"#%E7%9B%AE%E5%BD%95\" aria-label=\"目录 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>目录</h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#node-%E7%9A%84%E7%89%B9%E7%82%B9\">Node 的特点</a></li>\n<li><a href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B\">异步编程</a></li>\n<li><a href=\"#callback-function\">Callback Function</a></li>\n<li><a href=\"#promise\">Promise</a></li>\n<li><a href=\"#generator-function-co\">Generator Function (co)</a></li>\n<li><a href=\"#async-await-function\">Async Await Function</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"node-的特点\" style=\"position:relative;\"><a href=\"#node-%E7%9A%84%E7%89%B9%E7%82%B9\" aria-label=\"node 的特点 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node 的特点</h2>\n<p>什么是 Node.js 呢？看一下<a href=\"https://nodejs.org/en/\">官网</a>正式的介绍：</p>\n<blockquote>\n<p>Node.js is a JavaScript runtime built on Chrome's V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.</p>\n</blockquote>\n<p>从这里可以知道，Node.js 有以下特点：</p>\n<ol>\n<li>Node.js 不是某种新的语言、不是 JavaScript 框架，也不是 nginx 一样的 Web 服务器。而是一个 JavaScript 运行时环境。跟浏览器类似，可以理解为运行 JavaScript 的一个环境，都是基于 Chrome V8，不同的是 Node.js 可以超越浏览器的限制，有更多的权限，可以干系统层级的活。</li>\n<li>Node.js 是事件驱动（event-driven）和非阻塞 I/O 模型（non-blocking I/O model），这意味着 Node.js 是以异步的方式处理函数工作流，底层是由 C/C++ 编写的 Libuv 这个库处理 事件循环和I/O 操作，隐藏了非阻塞 I/O 的具体细节，简化并发模型。</li>\n<li>使用 npm 作为包管理器，管理应用的依赖。</li>\n</ol>\n<p>本文将整理 Node.js 处理异步流程的四个方案：</p>\n<ul>\n<li>初代光芒-Callback Function</li>\n<li>中流砥柱-Promise</li>\n<li>过渡方案-Generator Function (co)</li>\n<li>终极方案-Async Await Function</li>\n</ul>\n<p>其实还有像 Thunk、事件监听、发布/订阅这样的解决思路，但大浪淘沙下来，目前是由 Promise + Async 这两个重要技术挑大梁，是需要重点掌握的。</p>\n<h2 id=\"异步编程\" style=\"position:relative;\"><a href=\"#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B\" aria-label=\"异步编程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>异步编程</h2>\n<p>什么是异步？</p>\n<blockquote>\n<p>所谓\"异步\"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。\n这种不连续的执行，就叫做异步。相应地，连续的执行，就叫做同步。</p>\n</blockquote>\n<p>异步编程？</p>\n<blockquote>\n<p>如何优雅地处理异步流程，是推动异步编程发展的源动力。\n异步编程的语法目标，就是怎样让它更像同步编程。</p>\n</blockquote>\n<h2 id=\"callback-function\" style=\"position:relative;\"><a href=\"#callback-function\" aria-label=\"callback function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Callback Function</h2>\n<p>Callback 也就是所谓的回调函数，这个在 Node.js 刚发布的时候就存在了。它的风格 <strong>Error-First</strong>：</p>\n<ul>\n<li>当发生错误的时候，回调函数第一个参数为 error 对象</li>\n<li>当成功响应的时候，回调函数第一个参数为 null，第二个参数为具体的数据</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nfs<span class=\"token punctuation\">.</span><span class=\"token function\">open</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/open/some/file.txt'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'r'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err<span class=\"token punctuation\">,</span> fd</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n  fs<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span>fd<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">err</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throw</span> err<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Callback style 的 API 虽然可以处理 Node.js 异步流程，但最大的问题在于组合使用出现的<strong>回调地狱</strong>：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">step1</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">value1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">step2</span><span class=\"token punctuation\">(</span>value1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">value2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">step3</span><span class=\"token punctuation\">(</span>value2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">value3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">step4</span><span class=\"token punctuation\">(</span>value3<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">value4</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token comment\">// Do something with value4</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>这不仅丑陋而且项目复杂了非常难以维护。为了解决这个问题，Node.js 社区又推出了 Promise 方案。</p>\n<h2 id=\"promise\" style=\"position:relative;\"><a href=\"#promise\" aria-label=\"promise permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Promise</h2>\n<p>Promise 最早是在 commonjs 社区提出来的，当时提出了很多规范，比较接受的是promise/A规范。后来社区在这个基础上，提出了promise/A+规范，也就是实际上现在的业内推行的规范。ES6 也是采用的这种规范。</p>\n<p>Promise 意味着<strong>许愿/承诺</strong>一个还没有完成的操作，但在未来会完成的。与 Promise 最主要的交互方法是通过将一个函数传入它的<code>then</code> 方法从而获取得 Promise <code>resolved</code>（成功） 或 <code>rejected</code>（失败）的值。要点有三个：</p>\n<ul>\n<li>递归，每个异步操作返回的都是 Promise 对象</li>\n<li>状态机：三种状态转换，只在 Promise 对象内部可以控制，外部不能改变状态</li>\n<li>全局异常处理</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> util <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'util'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> stat <span class=\"token operator\">=</span> util<span class=\"token punctuation\">.</span><span class=\"token function\">promisify</span><span class=\"token punctuation\">(</span>fs<span class=\"token punctuation\">.</span>stat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">stat</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">stats</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 使用 `stats`。</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">catch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">error</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 处理错误。</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Promise 的最大优势是标准化，各类异步工具库都按照统一规范实现，即使是 async 函数也可以无缝集成。所以用 Promise 封装 API 通用性强，用起来简单，学习成本低。在 async 函数普及之前，绝大部分应用都是采用Promise来做异步流程控制的。</p>\n<p>但 Promise 也不是没有问题，过多的异步流程下， <code>then</code> 也会变得繁琐：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">doPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>有没有更像“同步编程”的方案呢？下面介绍的两个方案可以让异步代码更清晰。</p>\n<h2 id=\"generator-function-co\" style=\"position:relative;\"><a href=\"#generator-function-co\" aria-label=\"generator function co permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Generator Function (co)</h2>\n<p>首先简单了解下 Generator 的用法：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 定义一个 generators</span>\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">yield</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">yield</span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"baz\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> g <span class=\"token operator\">=</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\ng<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints \"bar\"</span>\ng<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// prints \"baz\"</span></code></pre></div>\n<p>简单来说，Generator 实现了状态暂停/函数暂停 —— 通过 yield 关键字暂停函数，并返回当前函数的状态。</p>\n<p>但单独的 Generator 函数需要手动去控制内部的状态，就像是手动挡的汽车，虽然比自行车跑得更快了但依旧繁琐，有没有带自动挡的新型工具呢？</p>\n<p>有的，早在 13 年 TJ 大神开发了一个叫 co 的库，实现了 Generator 的 自动执行，使用 co 和 Promise 修改上面的代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> co <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'co'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">yield</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bar\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">yield</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"baz\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>co 有个使用条件：Generator 函数的 yield 命令后面，只能是 Thunk 函数或 Promise 对象。</p>\n<p>这样就让 co 变得非常强悍，让我们的代码更上一层楼：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> co <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'co'</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Promise 化的API</span>\n<span class=\"token keyword\">const</span> readFile <span class=\"token operator\">=</span> util<span class=\"token punctuation\">.</span><span class=\"token function\">promisify</span><span class=\"token punctuation\">(</span>fs<span class=\"token punctuation\">.</span>readFile<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 包装执行</span>\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">const</span> data <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./package.json'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">const</span> data2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">readFile</span><span class=\"token punctuation\">(</span><span class=\"token string\">'./file.text'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>data2<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>是不是更有“同步代码”的味道了，不用纯 Promise <code>then</code> 套 <code>then</code> 那种 style 了。</p>\n<h2 id=\"async-await-function\" style=\"position:relative;\"><a href=\"#async-await-function\" aria-label=\"async await function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Async Await Function</h2>\n<p>Async/Await 是当前 Node.js，也是 JavaScript 领域终极的异步解决方案，它集合了 Promise 和 Generator 的优点，是更高程度的一个抽象。来直接看看它长什么样：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> util <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'util'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> fs <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fs'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> stat <span class=\"token operator\">=</span> util<span class=\"token punctuation\">.</span><span class=\"token function\">promisify</span><span class=\"token punctuation\">(</span>fs<span class=\"token punctuation\">.</span>stat<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">callStat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> stats <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">stat</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">该目录归 </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>stats<span class=\"token punctuation\">.</span>uid<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\"> 拥有</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>而且即便函数中没有特别指定，<code>async</code> 关键词也能将这个函数的返回用 Promise 包装起来：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">aFunction</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token string\">'test'</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">aFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>alert<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// 等同于</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">aFunction</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'test'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">aFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>alert<span class=\"token punctuation\">)</span></code></pre></div>\n<p>可以看到 Async/Await 代码有点像上一节中搭配了 co 的 Generator 用法，非常的同步 style。其实与 Generator 和 Promise 相比，它有很多进步：</p>\n<ul>\n<li>语义非常好，清晰明了</li>\n<li>自带执行器，所以无需外部的 co 这类的库</li>\n<li>可以使用 try/catch 控制错误流程</li>\n<li>await 既可以接 Promise，也可以直接接 co（co 能返回 promise 对象），所以兼容特别好</li>\n<li>await 虽然没有并行机制，但搭配 Promise 的 race 和 all，几乎支持所有的异步场景</li>\n</ul>\n<p>综上所述，Async/Await 是 JavaScript 社区的终极利器。 作为前端方向的开发者，Async/Await + Promise 的组合是必须要掌握的！</p>\n<h2 id=\"参考\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考</h2>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000007057045\">co.js - 让异步代码同步化 - 听·说 - SegmentFault 思否</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/04/generator.html\">Generator 函数的含义与用法 - 阮一峰的网络日志</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/05/co.html\">co 函数库的含义和用法 - 阮一峰的网络日志</a></li>\n<li><a href=\"https://juejin.im/post/5a333fe1f265da431f4b1d5c\">node 异步编程 - 掘金</a></li>\n<li><a href=\"https://github.com/i5ting/How-to-learn-node-correctly#%E7%9F%A5%E4%B9%8Elive%E7%8B%BC%E5%8F%94%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AD%A6%E4%B9%A0nodejs\">GitHub - i5ting/How-to-learn-node-correctly: [全文]如何正确的学习Node.js</a></li>\n<li><a href=\"https://nodejs.dev/modern-asynchronous-javascript-with-async-and-await\">Modern Asynchronous JavaScript with Async and Await</a></li>\n</ul>","fields":{"slug":"/content/Node-Node 异步编程探究/"},"frontmatter":{"title":"Node 异步编程探究","category":"Node","tags":"Node_Basic 异步模型","date":"2020-03-27"}}},"pageContext":{"slug":"/content/Node-Node 异步编程探究/"}}}