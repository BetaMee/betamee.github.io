{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/content/WebFrontEnd-理解 requestIdleCallback/","result":{"data":{"site":{"siteMetadata":{"author":"橡树上","title":"十二棵橡树"}},"markdownRemark":{"id":"0091b400-8f27-5a9d-8092-6e61daad6710","html":"<h2 id=\"目录\" style=\"position:relative;\"><a href=\"#%E7%9B%AE%E5%BD%95\" aria-label=\"目录 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>目录</h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E8%B5%B7%E6%BA%90\">起源</a></li>\n<li><a href=\"#%E6%A6%82%E5%BF%B5\">概念</a></li>\n<li><a href=\"#%E7%90%86%E8%A7%A3%E6%AF%8F%E4%B8%80%E5%B8%A7\">理解每一帧</a></li>\n<li><a href=\"#requestIdleCallback-%E5%9B%9E%E8%B0%83%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C\">requestIdleCallback 回调可以做些什么工作</a></li>\n<li><a href=\"#requestIdleCallback-%E4%B8%8D%E8%83%BD%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BA%8B\">requestIdleCallback 不能操作的事</a></li>\n<li><a href=\"#%E6%80%BB%E7%BB%93\">总结</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"起源\" style=\"position:relative;\"><a href=\"#%E8%B5%B7%E6%BA%90\" aria-label=\"起源 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>起源</h2>\n<p>第一次知道 requestIdleCallback 这个 API, 是在学习 React Fiber 调度概念中得知的。我们知道 React 16 实现了新的调度策略 Fiber，可以异步和任务中断，其原理就是基于 requestIdleCallback 和 requestAnimationFrame 这两个概念 API。虽然 React 团队是自己实现了一套 requestIdleCallback 机制，不过还是有必要了解一下 requestIdleCallback 这个 API 的来龙去脉。</p>\n<h2 id=\"概念\" style=\"position:relative;\"><a href=\"#%E6%A6%82%E5%BF%B5\" aria-label=\"概念 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>概念</h2>\n<p>什么是 requestIdleCallback？为什么要推出这个 API？MDN 上对于其定义：</p>\n<blockquote>\n<p> window.requestIdleCallback() 方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。</p>\n</blockquote>\n<p>看得云里雾里。说人话就是，requestIdleCallback 中的任务是比较低优先级的，只有在浏览器空闲的时候才会运行。相比于 requestAnimationFrame（可简称 rAF），rAF 的回调会在每一帧确定执行，属于高优先级任务，requestIdleCallback 的回调是低优先级，不一定会在一帧之内执行。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">requestIdelCallback</span><span class=\"token punctuation\">(</span>myNonEssentialWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">myNonEssentialWork</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">deadline</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// deadline.timeRemaining()可以获取到当前帧剩余时间</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>deadline<span class=\"token punctuation\">.</span><span class=\"token function\">timeRemaining</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> tasks<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">doWorkIfNeeded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tasks<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      <span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span>myNonEssentialWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"理解每一帧\" style=\"position:relative;\"><a href=\"#%E7%90%86%E8%A7%A3%E6%AF%8F%E4%B8%80%E5%B8%A7\" aria-label=\"理解每一帧 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>理解每一帧</h2>\n<p>让我们来看一下每一帧浏览器会做什么：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.4%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABe0lEQVQY032PzWoTYQBF511c+iQuXHXtwr2+QMWF2K2Ky6AgKiIIUmkqqdSWkBhjbWImyUx+ZjKT+eH75j/fpInUVY+DuBM8cBaXu7lXu7z8het6eH6AlDGOu8TzAq74l6u//g9tuykoUheV+2SJgyoEeepTqoS1EmTxosoeZWaxXRn8rMwiiyQqiUSBjCV5GZMWErUu0DI5xp99QCyOcM19QqdF7DVJxZAkaFddnYukS2y/YdTcJRzuYfVe0aj3aJ8YdPtdvo0/09GPsf0JmsodtnmfTT5gJc9Qqck61SlzG+k28aZ10qCJsN5h955QODWkdUCnZdA/m6MbAwznHFuMEdUzLTBfYHy6wfeDHYaNm1jdXcz2Pfzpexb2nB/np1jWjE7jAftPr3H0/Dq1hzvcvf2WO7de8vjZI16f7lE7vE979BFtoxzi5TGiWhMtT1DJgCLS2ZQhK7UhimLy4gIZTrBHh7iTBlP9C19bsz+acxMr1Jks+6QrwW+BXaVTyEpG4QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"2c9683f1.png\"\n        title=\"2c9683f1.png\"\n        src=\"/static/c2e00dc71bec700348b4e8f65cfeb2f2/00d43/2c9683f1.png\"\n        srcset=\"/static/c2e00dc71bec700348b4e8f65cfeb2f2/63868/2c9683f1.png 250w,\n/static/c2e00dc71bec700348b4e8f65cfeb2f2/0b533/2c9683f1.png 500w,\n/static/c2e00dc71bec700348b4e8f65cfeb2f2/00d43/2c9683f1.png 1000w,\n/static/c2e00dc71bec700348b4e8f65cfeb2f2/aa440/2c9683f1.png 1500w,\n/static/c2e00dc71bec700348b4e8f65cfeb2f2/e8950/2c9683f1.png 2000w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>图中一帧包含用户的交互、js的执行、以及requestAnimationFrame的调用，布局计算以及页面的重绘等工作。假如某一帧里面要执行的任务不多，在不到16ms（按 60FPS 算，1000/60)的时间内就完成了上述任务的话，那么这一帧就会有一定的空闲时间，这段时间就恰好可以用来执行 requestIdleCallback 的回调，如下图所示：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 717px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABNUlEQVQoz41RTU+DQBTk/596MH4kjfHgyZN3Y2LUVJOGtFq/WhWqSKR8Swq2LG/HBy0f1kadMJnlMTvLvqcIISClRI5SSzTr65gjy7KCpU+x7cmfG38ENQLDMIDv+3Xg6onrQ5p//Z2rexQial4SayFnCJwb+M4ANNOAVF9Q6PzOpKyyKoYXo/vo4mocYPgeQ332MHgNWV2u27gcurgfG7A723g7amFyuoGwuwP3bBPWcQvR7QE0e4oe+z/nAorpJ1CfXFy/BBhZU9YQd2aEvu5z3eFQDyPDRNTbh3vehtNp40Pdg3exC+tkC9HDIXQnRl/jwJQD8ylDEj8E4mlVyjUUlHwlwZOMQTIpWKwp4U8JhIiZadGuaih5H2nZ1EppWWeWg8nbTYsz2FevS38RiH9D/sIaX5jlt6HVSjImAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"666a1305.png\"\n        title=\"666a1305.png\"\n        src=\"/static/2bb79a68218c3d465f1d0174efa73e34/0ad97/666a1305.png\"\n        srcset=\"/static/2bb79a68218c3d465f1d0174efa73e34/63868/666a1305.png 250w,\n/static/2bb79a68218c3d465f1d0174efa73e34/0b533/666a1305.png 500w,\n/static/2bb79a68218c3d465f1d0174efa73e34/0ad97/666a1305.png 717w\"\n        sizes=\"(max-width: 717px) 100vw, 717px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>当程序栈为空页面无需更新的时候，浏览器其实处于空闲状态，这时候留给 requestIdleCallback 执行的时间就可以适当拉长，最长可达到 50ms，以防出现不可预测的任务（用户输入）来临时无法及时响应可能会引起用户感知到的延迟。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 670px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 26%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcklEQVQY02NgYGAQBGJ2IGZLT/aW+v//NFdYsL28jpaCdXlxuNiDm0u5M5I9xVIT3CW/vN3CFRPpLKOtJW+TmxUgDuRzJ8S6SgD1CgMxHwMI9G98yBv3+D/rpg1zNS8dnn3z5qnFtz882Hrj18t9N74+2Xnr54u9d97cWX/6ze31d4DsW9+f7b754/mem9+e7roJVHP3xY21p6fM6FPouPafY8nZ/9wMqw7cOj1t9eGLO49eOPH6UPf/J/sn/H9zdPL/H2em/H92YAIQT/z/79K0T59O9v9/CpR7DZT7eW4qULwfLP/59LSvW45cPjxz7eFLK/bfPsrQMmOjSWJRh3VH/ySnG7vaSh4fnVT26PCE0seH+8oeAun7BydU3NvfmfPwUHfRw8MTyx4emlD28uSkklPrGmvPbmiuv723K7ehe4pdbE69Q8uMTUYMJ1/+Z/j/Hxd+CwoVFiDm+v//PZL4QZC4KCj8//+/CRfff/c/AwALV++JGj9/gAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"eb7f0a8c.png\"\n        title=\"eb7f0a8c.png\"\n        src=\"/static/7b7e7b15d501c83d3f661125bb1a0e16/d67fd/eb7f0a8c.png\"\n        srcset=\"/static/7b7e7b15d501c83d3f661125bb1a0e16/63868/eb7f0a8c.png 250w,\n/static/7b7e7b15d501c83d3f661125bb1a0e16/0b533/eb7f0a8c.png 500w,\n/static/7b7e7b15d501c83d3f661125bb1a0e16/d67fd/eb7f0a8c.png 670w\"\n        sizes=\"(max-width: 670px) 100vw, 670px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>由于 requestIdleCallback 利用的是帧的空闲时间，所以就有可能出现浏览器一直处于繁忙状态，导致回调一直无法执行，这其实也并不是我们期望的结果（如上报丢失），那么这种情况我们就需要在调用requestIdleCallback 的时候传入第二个配置参数 timeout 了:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span>myNonEssentialWork<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> timeout<span class=\"token operator\">:</span> <span class=\"token number\">2000</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">myNonEssentialWork</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">deadline</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 当回调函数是由于超时才得以执行的话，deadline.didTimeout为true</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>deadline<span class=\"token punctuation\">.</span><span class=\"token function\">timeRemaining</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> deadline<span class=\"token punctuation\">.</span>didTimeout<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span>\n         tasks<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token function\">doWorkIfNeeded</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>tasks<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">requestIdleCallback</span><span class=\"token punctuation\">(</span>myNonEssentialWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>如果是因为 timeout 回调才得以执行的话，其实用户就有可能会感觉到卡顿了，因为一帧的执行时间必然已经超过 16ms 了。</p>\n<h2 id=\"requestidlecallback-回调可以做些什么工作\" style=\"position:relative;\"><a href=\"#requestidlecallback-%E5%9B%9E%E8%B0%83%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%E5%B7%A5%E4%BD%9C\" aria-label=\"requestidlecallback 回调可以做些什么工作 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>requestIdleCallback 回调可以做些什么工作</h2>\n<p>上面讲了这么多概念，那么实际应用中，我们可以用 requestIdleCallback 做些什么呢？</p>\n<p>本文参考有两篇文章，可以看到别人对于 requestIdleCallback 的应用，我们可以在 idle callback 中做一些：</p>\n<ul>\n<li>小段的非交互相关的代码，比如点击的时候发送埋点数据，可以在空闲时间才让浏览器发送，避免影响体验</li>\n<li>类似于 prefetch，利用浏览器空闲时间，可以提前请求下一页的资源</li>\n</ul>\n<h2 id=\"requestidlecallback-不能操作的事\" style=\"position:relative;\"><a href=\"#requestidlecallback-%E4%B8%8D%E8%83%BD%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BA%8B\" aria-label=\"requestidlecallback 不能操作的事 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>requestIdleCallback 不能操作的事</h2>\n<ol>\n<li>requestIdleCallback 不能写阻塞代码</li>\n</ol>\n<p>requestIdleCallback 中的任务应该是可以预测的小块任务，如果出现同步阻塞的代码，那么它也会直接卡死浏览器。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 27.999999999999996%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAABNUlEQVQY01WQWUvDQBRG8///jAo++eAGLq20WuKWuiRpaxdtY5vMJJPJJMcbRbQXDud+MHxcxitLQ0NNtZgJU8q6wiYrqjikGkeUcYwKY9wklvyHG2/nllrwrC1px0mhm0+lWkZtaEYvVKNQCiOylxAne/VN9Od4O9diT+ucQivM+pNKim7jAcfnXd4mKS5JyGdzirSg0ZpaKRqVibPv/b+d0EiPN/CH7O0cMAyeOLm8Y+egi397Rfhwwmh4RqdzSu+mRxD0eRx0ST5WGFtjihJj7BZl6fAen+65GOySFzlRlOL7CVotWT8HzEY+R3f7HD4ccv56RH/aYbKYk642ZMtPstVavP6xoJINXjD+4PrdRxuHdWAqh5ZvVUuHUpYkz1mkmo3JSa2hkOsKC3mLvGv3X9r8BeAHwdYVLaOzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"a5a0b6dd.png\"\n        title=\"a5a0b6dd.png\"\n        src=\"/static/20e7452a79fd5223ac21877a58742c39/00d43/a5a0b6dd.png\"\n        srcset=\"/static/20e7452a79fd5223ac21877a58742c39/63868/a5a0b6dd.png 250w,\n/static/20e7452a79fd5223ac21877a58742c39/0b533/a5a0b6dd.png 500w,\n/static/20e7452a79fd5223ac21877a58742c39/00d43/a5a0b6dd.png 1000w,\n/static/20e7452a79fd5223ac21877a58742c39/aa440/a5a0b6dd.png 1500w,\n/static/20e7452a79fd5223ac21877a58742c39/e8950/a5a0b6dd.png 2000w,\n/static/20e7452a79fd5223ac21877a58742c39/d8fc6/a5a0b6dd.png 2052w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<ol start=\"2\">\n<li>requestIdleCallback 不能进行 DOM 操作</li>\n</ol>\n<p>从上面一帧的构成里面可以看到，requestIdleCallback 回调的执行说明前面的工作（包括样式变更以及布局计算）都已完成。如果我们在 callback 里面做 DOM 修改的话，之前所做的布局计算都会失效，而且如果下一帧里有获取布局（如 getBoundingClientRect、clientWidth）等操作的话，浏览器就不得不执行强制重排工作,这会极大的影响性能，另外由于修改 DOM 操作的时间是不可预测的，因此很容易超出当前帧空闲时间的阈值，故而不推荐这么做。推荐的做法是在 requestAnimationFrame 里面做 DOM 的修改，可以在 requestIdleCallback 里面构建 Document Fragment，然后在下一帧的 requestAnimationFrame 里面应用 Fragment。</p>\n<p>推荐放在 requestIdleCallback 里面的应该是小块的并且可预测时间的任务。</p>\n<h2 id=\"总结\" style=\"position:relative;\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-label=\"总结 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h2>\n<p>对 requestIdleCallback 进行一个总结：</p>\n<ul>\n<li>在浏览器一帧的空闲时间运行 idle 回调，是低优先级任务</li>\n<li>空闲时间最多 50ms 执行回调，防止意外的用户事件没有响应</li>\n<li>加一个 timeout，防止 idle 回调一直得不到响应</li>\n<li>不能在 idle 回调同步阻塞代码</li>\n<li>不能在 idle 回调中修改 DOM</li>\n</ul>\n<h2 id=\"参考\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考</h2>\n<ul>\n<li><a href=\"https://developers.google.com/web/updates/2015/08/using-requestidlecallback\">Using requestIdleCallback  |  Web  |  Google Developers</a></li>\n<li><a href=\"https://juejin.im/post/6844903592831238157\">你应该知道的 requestIdleCallback</a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback\">requestIdleCallback - Web API 接口参考 - MDN</a></li>\n<li><a href=\"https://medium.com/@nuno.andrade/prefetch-assets-using-requestidlecallback-a578ea8f0e3c\">Prefetch assets using requestIdleCallback | by Nuno Andrade | Medium</a></li>\n<li><a href=\"https://jgw96.github.io/MyBlog/2017/01/11/RequestIdleCallback/\">requestIdleCallback, Let the browser work for you! · Justin on WEB</a></li>\n</ul>","fields":{"slug":"/content/WebFrontEnd-理解 requestIdleCallback/"},"frontmatter":{"title":"理解 requestIdleCallback","category":"WebFrontEnd","tags":"WebAPI","date":"2020-11-09"}}},"pageContext":{"slug":"/content/WebFrontEnd-理解 requestIdleCallback/"}},"staticQueryHashes":["3649515864"]}