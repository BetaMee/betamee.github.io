{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/content/WebFrontEnd-浏览器中 JavaScript 单线程运行机制/","result":{"data":{"site":{"siteMetadata":{"author":"橡树上","title":"十二棵橡树"}},"markdownRemark":{"id":"d7705a95-ea88-57a4-a001-3b4f95c48b5e","html":"<blockquote>\n<p>本文主要整理浏览器中的 JavaScript 运行机制。\n另外注意一点，由于历史原因，<strong>本文中提到的作对比的 Node，指的是 v11 以下的版本！</strong> v11 以上的版本中，事件循环表现已经和浏览器一致了！具体见另一篇整理的《Node 事件循环机制》</p>\n</blockquote>\n<h2 id=\"目录\" style=\"position:relative;\"><a href=\"#%E7%9B%AE%E5%BD%95\" aria-label=\"目录 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>目录</h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E5%8C%BA%E5%88%86%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5\">区分进程和线程的概念</a></li>\n<li><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\">浏览器中进程和线程</a></li>\n<li><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%88%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89%E4%B8%AD%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\">浏览器内核（渲染进程）中各个线程之间的关系</a></li>\n<li><a href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6\">事件循环机制</a></li>\n<li><a href=\"#%E5%8C%BA%E5%88%86%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\">区分宏任务和微任务</a></li>\n<li><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B\">浏览器渲染流程</a></li>\n<li><a href=\"#%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3\">一些代码理解</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"区分进程和线程的概念\" style=\"position:relative;\"><a href=\"#%E5%8C%BA%E5%88%86%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5\" aria-label=\"区分进程和线程的概念 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>区分进程和线程的概念</h2>\n<p>首先我们得先理解一下计算机中常见的进程和线程概念。做一个形象的比喻：</p>\n<blockquote>\n<p>进程是一个工厂，工厂有独立的资源  ->  系统分配的内存（独立的一块内存）\n各个工厂相互独立 -> 进程之间相互独立\n线程是工厂中的工人，多个工人协作完成任务 -> 多个线程在进程中协作完成任务\n工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成\n工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</p>\n</blockquote>\n<p>用正式术语总结一下：</p>\n<ul>\n<li>进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>\n<li>线程是 CPU 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>\n</ul>\n<h2 id=\"浏览器中进程和线程\" style=\"position:relative;\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\" aria-label=\"浏览器中进程和线程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>浏览器中进程和线程</h2>\n<p>到这里让，我们回到浏览器中，对浏览器运行作出一个正确的理解：</p>\n<ol>\n<li>浏览器是多进程的，有 Browser 进程（主进程）、插件进程、GPU 进程（最多一个，用于绘制）、浏览器渲染进程</li>\n<li>每一个新开 tab 页面相当于新的一个渲染进程，所以各个页面之间崩溃了也不会影响，缺点是占用内存，比如 Chrome 就很占内存（以前是有单进程的浏览器的）</li>\n<li>浏览器渲染进程内部是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行。这是本文重点讲解的进程。</li>\n<li>JavaScript 的执行是单线程的，这个是众所周知的知识点。</li>\n</ol>\n<p>总结一下，我们常说 JavaScript 是一门的单线程语言，这话没错，但放在浏览器的世界中，还需要其他进程/线程的配合，才能让一个页面完美运行。</p>\n<h2 id=\"浏览器内核（渲染进程）中各个线程之间的关系\" style=\"position:relative;\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%88%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89%E4%B8%AD%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\" aria-label=\"浏览器内核（渲染进程）中各个线程之间的关系 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>浏览器内核（渲染进程）中各个线程之间的关系</h2>\n<p>对前端来说，最重要的是理清渲染进程的运行机制，渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环这些线程都在这个进程下打配合。</p>\n<p>下面分析一下渲染进程中主要的线程：</p>\n<ul>\n<li>\n<p>GUI 渲染线程</p>\n<ul>\n<li>负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等</li>\n<li>当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行</li>\n</ul>\n</li>\n<li>\n<p>JS 引擎线程</p>\n<ul>\n<li>也称为JS内核，负责解析 Javascript 脚本，运行代码（如 Chrome 中的 V8）</li>\n<li>JS 引擎一直等待着<strong>任务队列</strong>中的任务（事件循环机制塞进来的回调函数）到来，然后加以处理</li>\n<li>有且只有一个 JS 线程在运行</li>\n</ul>\n</li>\n<li>\n<p>事件触发线程</p>\n<ul>\n<li>属于浏览器而不是 JS 引擎，用来控制事件循环</li>\n<li>当 JS 引擎执行如鼠标点击、AJAX 异步请求、定时等异步任务时，在到达定时时间或者是 AJAX 请求成功后，把被触发的事件（也就是回调函数）放到<strong>任务队列</strong>当中，等 JS 引擎空闲了再处理</li>\n</ul>\n</li>\n<li>\n<p>定时触发器线程</p>\n<ul>\n<li><code>setInterval</code> 与 <code>setTimeout</code> 所在线程</li>\n<li>浏览器定时计数器并不是由 JS 引擎计数的,（因为 JS 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li>\n<li>计时完毕后，添加定时事件到<strong>任务队列</strong>中，等待 JS 引擎空闲后执行</li>\n<li>W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于4ms的时间间隔算为4ms</li>\n</ul>\n</li>\n<li>\n<p>异步 AJAX 请求线程</p>\n<ul>\n<li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li>\n<li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个状态变更事件（代码中的回调函数）再放入<strong>任务队列</strong>中，再由 JS 引擎执行</li>\n<li>当请求结束后，该线程可能就会被销毁</li>\n</ul>\n</li>\n</ul>\n<p>这里再多说几句解释：</p>\n<ol>\n<li>GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</li>\n<li>事件触发线程干的活可以理解为只是调度各种异步事件（如定时器，AJAX 请求），将已经完事的异步任务产生的事件（回调）塞到任务队列里，所以要注意，定时任务、http 请求处理过程都是由各自的线程处理的，而不是事件触发线程亲自上阵干这些脏活</li>\n<li><strong>任务队列</strong>专门加粗，这是一个重要概念，后面事件循环中会讲到</li>\n</ol>\n<h2 id=\"事件循环机制\" style=\"position:relative;\"><a href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6\" aria-label=\"事件循环机制 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>事件循环机制</h2>\n<p>事件循环（Event Loop）是前端领域中非常重要的一个概念，因为 JavaScript 是单线程工作的，而 JavaScript 执行的任务有同步和异步之分。事件循环机制是用于协调同步和异步之间的流程。</p>\n<ul>\n<li>同步任务：主线程上排队执行的任务，生成一个<strong>执行栈</strong>，按顺序执行</li>\n<li>异步任务：不在主线程而进入\"任务队列\"（task queues）的任务，如 DOM 事件、AJAX 请求、定时器等。先交由各自的异步线程处理，完成后扔进任务队列中，等待主线程空闲后捞起</li>\n<li>任务队列（也可以叫消息队列）：类似队列的数据结构，遵循先入先出(FIFO)的规则。由事件触发线程管理，将可以运行的异步任务添加到可主线程执行栈中</li>\n</ul>\n<p>以下面的代码进行举例理解：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bar'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'baz'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>baz<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// foo</span>\n<span class=\"token comment\">// bar</span>\n<span class=\"token comment\">// baz</span></code></pre></div>\n<p>这段代码中，<code>foo()</code>、<code>bar()</code> 是同步任务，所以会先执行，<code>setTimeout</code> 是异步任务，所以在 \"0ms\" 后，事件触发线程将 <code>baz()</code> 放入任务队列中，等待主线程空闲后，再取出<code>baz()</code> 这个回调函数，放入执行栈，进行消化。</p>\n<p>下面的流程图完整的展示了这个过程：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 601px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsSAAALEgHS3X78AAADuElEQVQ4y22Uy2tcVRzH70aULsQWY1yKu/rExC7EXcV/wUWpIBHMQt11YUEUsbFVKkKxlroQhK6k1oBdRJuqCc1rkkyamkczj85MM5nHnekkd+Y+z71zP/7OzaRNixe+nPP7nd/5nt/zGt04Qn+WU+Ha/EmC+FtikbsoQZQgisOH9o9iv43heG1cD7xwjp9+Nbg++SahvOF4HYFN2FUPEe0njvXuEb3hBW7ikfhIvXEZszmfSPrQdjoEod8jUETdQB7zCbVOSPzAoSs6DX2miY3tnRa3bqVZW1vH86F5z2JxMUU+n6XdaaMiuYB4we4nwTC7dJO5m8vMpJcp1c2eA/RCdm0q1TKblRK2a2G1m5Tu5mi2anTsPcIY1anjF1L4dxZxc3M42RnZpxIEhXmCzWXx0sfwA4+9z3Ndydl9UQgdlHKSvVr5BfPjx5h69xBTxw8ycewgN449xfg7h9h47wDtzw6j7AbGeqnB6KLFmHeVQrtEqFbYcf7CVRP4qoXugh1XcWfyAlvfvUThm9fJnB4kJ8h+NZjIxdOvUrnwNpHXxOgoRW01w2p5kpYKpbJDFOvP0XQOU966TmajQK5UJj9xnn/PvCAYZGlkgJWvX2Ph1ADzpwaZ/+IVMt8fJfZNDJ3sYHmaMJuV1IMffkS5MUA7eAPTnMIV75KQ85fYvvg45fP9pL/sY2Wkj8XPnyZz5hl2zj2JdWmAMGhh2LbN9N9FpCGSKnvRh1S3XxbCI9IyK5Lo3Qp61X+wrh3H/HOY/OgwuctD5K58QPnqMNYfQ3SmThJFNobreaQn85J8b5cwfJ9K63khfFHkpaRI3ThISOMH9WLTtO7v4x50vo1A+YlSN66SEVHRKkE0i6emcdyGEEb7GtuTxvaI5YFc9jaBdIBulUh0eu2KjXGv1aBYLLBVKVMs6dVkbGxcClLfbejYk1VPi0xCssqkCHFOGn//yGlbDaNuVmUqNmg062Rzt6nWTGZnbouumXiu51rnUUOHr0NrbUesr68lgepZ3z/Phh5wrVQ6lMQkLfhE8Clh/KOYjIjFCVl/FpwV/Qnx46w85Mojkgq5G/aQEFaqW8zOzpBKTZPNVnHUD9KHBrlNA1sNstV8gmLNoNk+imn1sXHXwGz3y+VOMpK7aQl7I5r8vmwWFlKk0ynpO1eqfJGSaVCoGlj+EanmAfIVIbHeorbTT6ZsUGs9K5fbQvQ/hHuCrqLOkeoW5GBU3v5d5Buyjkkirsj5jJiPy/43OR9Pqh12Q1l1uh6E/B/Z7xD9PofBzgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"浏览器事件循环机制\"\n        title=\"浏览器事件循环机制\"\n        src=\"/static/6f1f7bc71e88e17f1b828d75fff797c2/d8f62/eventloop.png\"\n        srcset=\"/static/6f1f7bc71e88e17f1b828d75fff797c2/63868/eventloop.png 250w,\n/static/6f1f7bc71e88e17f1b828d75fff797c2/0b533/eventloop.png 500w,\n/static/6f1f7bc71e88e17f1b828d75fff797c2/d8f62/eventloop.png 601w\"\n        sizes=\"(max-width: 601px) 100vw, 601px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>这里 stack 是主线程的执行栈，heap 是代码中用到的数据（各种对象数组），callback queue 就是任务队列，所有经由 Web API 这些异步线程处理完后的回调事件将统统放在这个队列里，等待主线程空闲时捞起。</p>\n<h2 id=\"区分宏任务和微任务\" style=\"position:relative;\"><a href=\"#%E5%8C%BA%E5%88%86%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\" aria-label=\"区分宏任务和微任务 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>区分宏任务和微任务</h2>\n<p>对于任务队列，我们需要进一步进行细分，目前有两类任务</p>\n<ul>\n<li>宏任务（Marcotasks 大部分事件）：setTimeout setInterval、setImmediate、I/O等各种事件（比如鼠标单击事件）的回调函数</li>\n<li>微任务（Microtasks，少数事件）：then（promise）、messageChannel、mutationObersve（不兼容）</li>\n</ul>\n<p>区别在于，微任务在本轮Event Loop的所有任务结束后执行，即栈清空后，先执行微任务，再检查任务队列，继续压入栈中执行。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 628px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAABB0lEQVQY01WQPUvDUBSG+6PESXBx83fo4ujQQd2cdVLo5FZ0cBEchEaKtJamDg5CJOlVU/JF26RGU0x6mzzeRBB9p3Pfe857n3NrKI2fLJzeI39l3nR5aQ/+eYHv4zoOURT9egspEb17XNOszrXiM+Foc5f6yjYf1ivzXBKZgv3VLQ7Xd/gaT5inKSPbRmu1uGieo/d1siwjjmN8z0fbWEPbq5OVgcgF7eMmVwcNpAqXRaGezbg7vaR/dg1FjnIIp1Me9AHdTqeiLFRfvlwi1Z3ROEHcaj+E0WyGEBZD65myrr5gMsW2BY474l1RlCpJDMMgDENMtV6SJKSK/E2R+0Gg5od4nsc30gIfCLMOtBcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"宏任务和微任务\"\n        title=\"宏任务和微任务\"\n        src=\"/static/57034522695881a7a51e8d2a325c2802/3d84d/tasks.png\"\n        srcset=\"/static/57034522695881a7a51e8d2a325c2802/63868/tasks.png 250w,\n/static/57034522695881a7a51e8d2a325c2802/0b533/tasks.png 500w,\n/static/57034522695881a7a51e8d2a325c2802/3d84d/tasks.png 628w\"\n        sizes=\"(max-width: 628px) 100vw, 628px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>所以同样的异步场景，微任务要比宏任务先执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise1'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout2'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout1'</span><span class=\"token punctuation\">)</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise2'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Promise1</span>\n<span class=\"token comment\">// setTimeout1</span>\n<span class=\"token comment\">// Promise2</span>\n<span class=\"token comment\">// setTimeout2</span></code></pre></div>\n<ul>\n<li>一开始执行栈的同步任务执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出 Promise1，同时会生成一个宏任务 setTimeout2</li>\n<li>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li>\n<li>在执行宏任务 setTimeout1 时会生成微任务 Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li>\n<li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li>\n</ul>\n<p>不过这里有一点要注意的，浏览器和 Node 中对于微任务的处理方式有所不同。因为 Node 中的事件循环是跟浏览器完全不是一个东西，是由 libuv 进行实现的。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 1000px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsSAAALEgHS3X78AAABjklEQVQoz1WQW2/TQBCF/f+feOANgZD6UCEhhESRgto0adJEuBVEbXpxgp02CdhOYudux17v+mOzQQhGOprR7uqbs8dSJZRlaaQnlFIUufhPIs+R+pxSYo8UJ46k8qMkWibIyCWPPISWjAdYe4gBcqhVvGJUuyVoPuI3HggvHX7Vu8TB1NzbQ8mn+4xKXxHOYlK3QeI2TRfPbazn5R+SSEHmFOka3/VYBwGbMGQzCVlHS7Is048U334qKo8pVVcSTiPS3ilJ/1z3MwqvjvXKTtmuFojWC8T9Bwr7JfLhPbLzGu6OoHvE39Jf3gO/9AuqXkkwmZH0qmz7NQMVgwssZ6p0bhKVzJmNn0hnPvl8xi4K2OlZrCMTh8m4VNhjxWenMBkG2mHmNdh5l6YXw/Yhw31t1gmjsw5BrWuyC1o9/Kajl0wO5gxQ0h4qPt7lnPRhMl+Rj76yG1+TjWyklqXUAVhkO+Ljd8zfvGVeqxM3WyyurhFF8Q+wZLJRPC0kg5sB2/ML8s530tsbhO8ba78BatEIWeEBHGkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"浏览器和Node端的差异\"\n        title=\"浏览器和Node端的差异\"\n        src=\"/static/d72f2de7309afe52603e5fc5855725dd/00d43/difference.png\"\n        srcset=\"/static/d72f2de7309afe52603e5fc5855725dd/63868/difference.png 250w,\n/static/d72f2de7309afe52603e5fc5855725dd/0b533/difference.png 500w,\n/static/d72f2de7309afe52603e5fc5855725dd/00d43/difference.png 1000w,\n/static/d72f2de7309afe52603e5fc5855725dd/58fee/difference.png 1051w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<ul>\n<li>浏览器环境下，微任务（Microtask） 的任务队列是每个宏任务（ Macrotask） 执行完之后执行。</li>\n<li>在 Node 中，微任务会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行微任务队列的任务。</li>\n</ul>\n<p>这些知识点在后面整理 Node 的事件循环机制中再作深入整理。</p>\n<h2 id=\"浏览器渲染流程\" style=\"position:relative;\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B\" aria-label=\"浏览器渲染流程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>浏览器渲染流程</h2>\n<p>这一节简单讲讲浏览器拿到数据后的渲染过程，详细内容可以另开一篇讲解。</p>\n<p>浏览器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p>\n<ol>\n<li>解析 HTML 建立 DOM 树</li>\n<li>解析 CSS 构建 Render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 Render 树）</li>\n<li>布局 Render 树（Layout/Reflow），负责各元素尺寸、位置的计算</li>\n<li>绘制 Render 树（Paint），绘制页面像素信息</li>\n<li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上</li>\n</ol>\n<p>所有详细步骤都已经略去，渲染完毕后就是<code>load</code>事件了，之后就是自己的 JS 逻辑处理了。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 900px;\"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAAB10lEQVQoz2N4/Hg78717W5kYgGDj0VtM2089YgGxV6w8y7d562379Zuvq4P4e8+8Ytx2+iHzlpP3GUF8IM1AEti6+aHy5vX3521acz8KXW7XhedgQ42MjDA1Pny4LfTe/a0+IPb6wzfMd114FjV3zWHR1g2dXMsv7oxcd/OQH9hFp+5p7Lr4tGj7uUcGIP7O809Yt5x6wBQRaMbw+PEOZiAG+5Lh5cs9b4BeXglkMm45dX/5qUe//i9ad9Zy9c3dvoc+3vy/5/Xl5SB1O04/t1iz9/rKjQcfOOD12rVrazlh7L65q3k6pi2WAIfnqWsmK/adaVt94FIEiL/u1gH9Ndf2Td50/1h4SdlEvt0Xn6VtPf3IKzbcjvXp053xQBwMNuT//4eM//9fYUW3aNORe7ZrD1xds/7o9X4gl3nDzaO1e15e+bft0Zlib4dEMWAQrFp/5FZVQpyvwKNH2xYAI7e7tTWHgeHWrY2vr11bvwJsyPE78/ZcevF//poTlgvPrLXf/vTsxx3Pzq6DWPyfkajYBEZK6okTy/ShScF/96UXzfOWn5LYcPuw6Z6XV3t2Pbvkjaz+zv8vDGVNXQzXPvxnOv/yP2NRYSLQsutM///fZnz5chcDAHqb+nMLKFCHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"浏览器渲染流程\"\n        title=\"浏览器渲染流程\"\n        src=\"/static/7a5ffc1fcdcfd71807009601b1178109/1cfc2/renderprocess.png\"\n        srcset=\"/static/7a5ffc1fcdcfd71807009601b1178109/63868/renderprocess.png 250w,\n/static/7a5ffc1fcdcfd71807009601b1178109/0b533/renderprocess.png 500w,\n/static/7a5ffc1fcdcfd71807009601b1178109/1cfc2/renderprocess.png 900w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>这里值得一提的是，在头部引入 CSS 资源的细节：</p>\n<ol>\n<li>CSS 加载过程不会阻塞 DOM 树解析（异步加载时DOM照常构建）</li>\n<li>CSS 解析过程会阻塞 Render 树构建（渲染时需等css加载完毕，因为render树需要css信息）</li>\n</ol>\n<p>另外还有图层合成（composite）的知识点，后面再整理。</p>\n<h2 id=\"一些代码理解\" style=\"position:relative;\"><a href=\"#%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3\" aria-label=\"一些代码理解 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>一些代码理解</h2>\n<p>这里贴一些奇奇怪怪的关于事件循环的代码，对比浏览器和 Node，以作理解：</p>\n<p>（注意⚠️：以下代码运行在 v11 以下的版本，v11 以上版本已经跟浏览器行为一致）</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 案例1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Node: 1 2 3 promise</span>\n<span class=\"token comment\">// 浏览器: 1 2 promise 3</span>\n\n<span class=\"token comment\">// 案例2</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Node: 2 4 1 3 promise 5</span>\n<span class=\"token comment\">// 浏览器：2 4 1 promise 3 5</span></code></pre></div>\n<h2 id=\"参考\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考</h2>\n<ul>\n<li><a href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 - 掘金</a></li>\n<li><a href=\"https://juejin.im/post/5be5a0b96fb9a049d518febc\">总结：JavaScript异步、事件循环与消息队列、微任务与宏任务 - 掘金</a></li>\n<li><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">Tasks, microtasks, queues and schedules - JakeArchibald.com</a></li>\n<li><a href=\"https://blog.csdn.net/Fundebug/article/details/86487117\">浏览器与Node的事件循环(Event Loop)有何区别?<em>Java</em>Fundebug博客-CSDN博客</a></li>\n<li><a href=\"http://lynnelv.github.io/js-event-loop-browser\">深入理解js事件循环机制（浏览器篇） - lynnelv's blog</a></li>\n</ul>","fields":{"slug":"/content/WebFrontEnd-浏览器中 JavaScript 单线程运行机制/"},"frontmatter":{"title":"浏览器中 JavaScript 单线程运行机制","category":"WebFrontEnd","tags":"Web_Deep 原理","date":"2020-04-20"}}},"pageContext":{"slug":"/content/WebFrontEnd-浏览器中 JavaScript 单线程运行机制/"}}}