{"componentChunkName":"component---src-templates-blog-template-tsx","path":"/content/webfrontend-a9df45bfb68f52299939acc4cf266ebf","result":{"data":{"site":{"siteMetadata":{"author":"橡树上","title":"十二棵橡树"}},"markdownRemark":{"id":"d7705a95-ea88-57a4-a001-3b4f95c48b5e","html":"<blockquote>\n<p>本文主要整理浏览器中的 JavaScript 运行机制。</p>\n<p>另外注意一点，由于历史原因，<strong>本文中提到的作对比的 Node，指的是 v11 以下的版本！</strong> v11 以上的版本中，事件循环表现已经和浏览器一致了！具体见另一篇整理的《Node 事件循环机制》</p>\n</blockquote>\n<h2 id=\"目录\" style=\"position:relative;\"><a href=\"#%E7%9B%AE%E5%BD%95\" aria-label=\"目录 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>目录</h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E5%8C%BA%E5%88%86%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5\">区分进程和线程的概念</a></li>\n<li><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\">浏览器中进程和线程</a></li>\n<li><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%88%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89%E4%B8%AD%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\">浏览器内核（渲染进程）中各个线程之间的关系</a></li>\n<li><a href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6\">事件循环机制</a></li>\n<li><a href=\"#%E5%8C%BA%E5%88%86%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\">区分宏任务和微任务</a></li>\n<li><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B\">浏览器渲染流程</a></li>\n<li><a href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB\">事件循环和浏览器渲染之间的联系</a></li>\n<li><a href=\"#%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3\">一些代码理解</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83\">参考</a></li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"区分进程和线程的概念\" style=\"position:relative;\"><a href=\"#%E5%8C%BA%E5%88%86%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5\" aria-label=\"区分进程和线程的概念 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>区分进程和线程的概念</h2>\n<p>首先我们得先理解一下计算机中常见的进程和线程概念。做一个形象的比喻：</p>\n<blockquote>\n<p>进程是一个工厂，工厂有独立的资源  ->  系统分配的内存（独立的一块内存）</p>\n<p>各个工厂相互独立 -> 进程之间相互独立</p>\n<p>线程是工厂中的工人，多个工人协作完成任务 -> 多个线程在进程中协作完成任务</p>\n<p>工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成</p>\n<p>工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</p>\n</blockquote>\n<p>用正式术语总结一下：</p>\n<ul>\n<li>进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）</li>\n<li>线程是 CPU 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）</li>\n</ul>\n<h2 id=\"浏览器中进程和线程\" style=\"position:relative;\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\" aria-label=\"浏览器中进程和线程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>浏览器中进程和线程</h2>\n<p>到这里让，我们回到浏览器中，对浏览器运行作出一个正确的理解：</p>\n<ol>\n<li>浏览器是多进程的，有 Browser 进程（主进程）、插件进程、GPU 进程（最多一个，用于绘制）、浏览器渲染进程</li>\n<li>每一个新开 tab 页面相当于新的一个渲染进程，所以各个页面之间崩溃了也不会影响，缺点是占用内存，比如 Chrome 就很占内存（以前是有单进程的浏览器的）</li>\n<li>浏览器渲染进程内部是多线程的，页面的渲染，JavaScript 的执行，事件的循环，都在这个进程内进行。这是本文重点讲解的进程。</li>\n<li>JavaScript 的执行是单线程的，这个是众所周知的知识点。</li>\n</ol>\n<p>总结一下，我们常说 JavaScript 是一门的单线程语言，这话没错，但放在浏览器的世界中，还需要其他进程/线程的配合，才能让一个页面完美运行。</p>\n<h2 id=\"浏览器内核（渲染进程）中各个线程之间的关系\" style=\"position:relative;\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%EF%BC%88%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B%EF%BC%89%E4%B8%AD%E5%90%84%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB\" aria-label=\"浏览器内核（渲染进程）中各个线程之间的关系 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>浏览器内核（渲染进程）中各个线程之间的关系</h2>\n<p>对前端来说，最重要的是理清渲染进程的运行机制，渲染进程是多线程的，页面的渲染，JavaScript 的执行，事件的循环这些线程都在这个进程下打配合。</p>\n<p>下面分析一下渲染进程中主要的线程：</p>\n<ul>\n<li>\n<p>GUI 渲染线程</p>\n<ul>\n<li>负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等</li>\n<li>当界面需要重绘（Repaint）或由于某种操作引发回流(Reflow)时，该线程就会执行</li>\n</ul>\n</li>\n<li>\n<p>JS 引擎线程</p>\n<ul>\n<li>也称为JS内核，负责解析 Javascript 脚本，运行代码（如 Chrome 中的 V8）</li>\n<li>JS 引擎一直等待着<strong>任务队列</strong>中的任务（事件循环机制塞进来的回调函数）到来，然后加以处理</li>\n<li>有且只有一个 JS 线程在运行</li>\n</ul>\n</li>\n<li>\n<p>事件触发线程</p>\n<ul>\n<li>属于浏览器而不是 JS 引擎，用来控制事件循环</li>\n<li>当 JS 引擎执行如鼠标点击、AJAX 异步请求、定时等异步任务时，在到达定时时间或者是 AJAX 请求成功后，把被触发的事件（也就是回调函数）放到<strong>任务队列</strong>当中，等 JS 引擎空闲了再处理</li>\n</ul>\n</li>\n<li>\n<p>定时触发器线程</p>\n<ul>\n<li><code>setInterval</code> 与 <code>setTimeout</code> 所在线程</li>\n<li>浏览器定时计数器并不是由 JS 引擎计数的,（因为 JS 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）</li>\n<li>计时完毕后，添加定时事件到<strong>任务队列</strong>中，等待 JS 引擎空闲后执行</li>\n<li>W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于4ms的时间间隔算为4ms</li>\n</ul>\n</li>\n<li>\n<p>异步 AJAX 请求线程</p>\n<ul>\n<li>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求</li>\n<li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个状态变更事件（代码中的回调函数）再放入<strong>任务队列</strong>中，再由 JS 引擎执行</li>\n<li>当请求结束后，该线程可能就会被销毁</li>\n</ul>\n</li>\n</ul>\n<p>这里再多说几句解释：</p>\n<ol>\n<li>GUI 渲染线程与 JS 引擎线程是互斥的，当 JS 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到JS引擎空闲时立即被执行</li>\n<li>事件触发线程干的活可以理解为只是调度各种异步事件（如定时器，AJAX 请求），将已经完事的异步任务产生的事件（回调）塞到任务队列里，所以要注意，定时任务、http 请求处理过程都是由各自的线程处理的，而不是事件触发线程亲自上阵干这些脏活</li>\n<li><strong>任务队列</strong>专门加粗，这是一个重要概念，后面事件循环中会讲到</li>\n</ol>\n<h2 id=\"事件循环机制\" style=\"position:relative;\"><a href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6\" aria-label=\"事件循环机制 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>事件循环机制</h2>\n<p>事件循环（Event Loop）是前端领域中非常重要的一个概念，因为 JavaScript 是单线程工作的，而 JavaScript 执行的任务有同步和异步之分。事件循环机制是用于协调同步和异步之间的流程。</p>\n<ul>\n<li>同步任务：主线程上排队执行的任务，生成一个<strong>执行栈</strong>，按顺序执行</li>\n<li>异步任务：不在主线程而进入\"任务队列\"（task queues）的任务，如 DOM 事件、AJAX 请求、定时器等。先交由各自的异步线程处理，完成后扔进任务队列中，等待主线程空闲后捞起</li>\n<li>任务队列（也可以叫消息队列）：类似队列的数据结构，遵循先入先出(FIFO)的规则。由事件触发线程管理，将可以运行的异步任务添加到可主线程执行栈中</li>\n</ul>\n<p>以下面的代码进行举例理解：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'bar'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">baz</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'baz'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'foo'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>baz<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">foo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// foo</span>\n<span class=\"token comment\">// bar</span>\n<span class=\"token comment\">// baz</span></code></pre></div>\n<p>这段代码中，<code>foo()</code>、<code>bar()</code> 是同步任务，所以会先执行，<code>setTimeout</code> 是异步任务，所以在 \"0ms\" 后，事件触发线程将 <code>baz()</code> 放入任务队列中，等待主线程空闲后，再取出<code>baz()</code> 这个回调函数，放入执行栈，进行消化。</p>\n<p>下面的流程图完整的展示了这个过程：</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 601px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 87.6%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAADvklEQVQ4y11US28bVRQeiQ1QpCYLxIIFEgskQIJEkUj+CUiURSUEa3a8BLRNaSseQUAXiD9QHgLUUAiIIJFGTRw7D9uxncROE8d2HL/nPXfuzPjjmzsOEEY6Oueee+93z3ceo0UIEWGIaGjj9t130By8CkAgHEZI9kLawRn7//Jfv2Y7JhzPJ2Abvy6P45ufHoXwTbhCwHEt+FKcuRDbfF5pKOvsg5rj2WobXJh2Ct3eJo8ll1zPgee7ybUYMGLkYfyQCd93YFkDCMH7ka/8KkLTMlAoZJHJpGGYguIinU4hn9+CbvCC9HCaliGSL7tbRiqbRypXRLl+rPzRSDTHtWHZOk7aTViOAdvV0e400NfbiNMhfE8dlHYHXm4eZmYe9sbPlNtwt+5Qz8Oh7W3NI3C6zCEB/TBUL0tfkOJpHCA1SUBb2cNODv23x7F+8TzuvjKGpZfHsHzhPP54cQxZ+ow3xiGqaWitXh/f3TOw4C5ibbCBoSyhZ92C6X0LP6iwKCEMV2A39QOqn0/i/o0J7MxOovzhBHavTqBybRIH1yewf/15yJMNaF4kYewf4n5+ET1yE+Iaat3H0bKeQLP1FXZKdRzUaqgXfkPpi2kU52aQ+2gGpblpZKnXb8xgk1L85AXI9iY0MWTZjyvMz7pqBCE/w0l/Cj17Crp5C46T0A97axh8/SBaXz6M9HvnsPX+I0i9dQ452v25h6DfHIPfJWDAcv+1UEZXd9gWgCc/Rcd6Gn33WVL+ETKAaiLfPoSV/gD66mU0l2ZR/f1d1P68hJOlKzBXLnPvKovSgOYHAuXtBkzDANMFV36MtvmMAhTye+YwbgehKj0cSfzVOxa9yXfqV23jClc5IwQIGKIMWxDBDly/yMZuMUI5mgZJBh6CwFVDUD2swDT7cexsak/txWc03ehjb28HR7UqdQnHzRP8cmcB29ulGIZg/ihCX0k4FASRqFT2OJ7OaPhORy+eFNsg2AEGBK43jtjUHZRY2VKxwctAQB5BONKU2OeRa6FY4lqORvLfOddiI55Xm/MZFyDCPim9TrnI9y7xyJv0vUQ9y/UVRnSB9mv0NVQRQ4LGwDL0E8CYcmp1FSsry6RZge0totrWsF3RMHCfwnHvMezVNDS6z6HL6ufpP+K+jLKj+ZWKagyofg4x6nYhj63sOhqNHg/eQ1PXUO9qMLxJdMwnUeto6BjTrPwUjmg3Bw8wqnzyjxomQP8AnnKH+okx3aFOnaG1xgMF2jnaK9QFtQZSXGcIaFJCRTcIE9oxzt8j9xDSIDaP4gAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"浏览器事件循环机制\"\n        title=\"浏览器事件循环机制\"\n        src=\"/static/6f1f7bc71e88e17f1b828d75fff797c2/d8f62/eventloop.png\"\n        srcset=\"/static/6f1f7bc71e88e17f1b828d75fff797c2/63868/eventloop.png 250w,\n/static/6f1f7bc71e88e17f1b828d75fff797c2/0b533/eventloop.png 500w,\n/static/6f1f7bc71e88e17f1b828d75fff797c2/d8f62/eventloop.png 601w\"\n        sizes=\"(max-width: 601px) 100vw, 601px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>这里 stack 是主线程的执行栈，heap 是代码中用到的数据（各种对象数组），callback queue 就是任务队列，所有经由 Web API 这些异步线程处理完后的回调事件将统统放在这个队列里，等待主线程空闲时捞起。</p>\n<h2 id=\"区分宏任务和微任务\" style=\"position:relative;\"><a href=\"#%E5%8C%BA%E5%88%86%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1\" aria-label=\"区分宏任务和微任务 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>区分宏任务和微任务</h2>\n<p>对于任务队列，我们需要进一步进行细分，目前有两类任务</p>\n<ul>\n<li>宏任务（Marcotasks 大部分事件）：setTimeout setInterval、setImmediate、I/O等各种事件（比如鼠标单击事件）的回调函数</li>\n<li>微任务（Microtasks，少数事件）：then（promise）、messageChannel、mutationObersve（不兼容）</li>\n</ul>\n<p>区别在于，微任务在本轮Event Loop的所有任务结束后执行，即栈清空后，先执行微任务，再检查任务队列，继续压入栈中执行。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 628px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 21.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVQY0z2Py0rDABBF+0cudCnu/A93gis3gltBwT9w4UbUhVofIAi+ioIiCKmlqSTNUyGhNbFNE01KmqY9Jil2YIaZO5fhTIks5KsnGueVvGWcl2HC884p9fId/zEajTANA01VcRxnqkdRxPvJER+CUMylpOOxtbDC+twy0afFb5rgNpqszSyxvbhK4vuE/T6GrnN7fcPh/gFVoUocx/hBQMuyuJ+f5XFzgzQ/mA5iXvcuedm9IE0GE8J0iHhWwXwQpiSe51F7q9EQRVzXZTzOnFkm2U4vH2OL9QlhblR0FUVT6PX8Qmy128iKjGZoBMFPoVkZidJU6Ha6SJJUvBqGIaZp8uV+o6oatm3zBzIWHhuTrsm1AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"宏任务和微任务\"\n        title=\"宏任务和微任务\"\n        src=\"/static/57034522695881a7a51e8d2a325c2802/3d84d/tasks.png\"\n        srcset=\"/static/57034522695881a7a51e8d2a325c2802/63868/tasks.png 250w,\n/static/57034522695881a7a51e8d2a325c2802/0b533/tasks.png 500w,\n/static/57034522695881a7a51e8d2a325c2802/3d84d/tasks.png 628w\"\n        sizes=\"(max-width: 628px) 100vw, 628px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>所以同样的异步场景，微任务要比宏任务先执行：</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\">Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise1'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout2'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'setTimeout1'</span><span class=\"token punctuation\">)</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=></span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Promise2'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Promise1</span>\n<span class=\"token comment\">// setTimeout1</span>\n<span class=\"token comment\">// Promise2</span>\n<span class=\"token comment\">// setTimeout2</span></code></pre></div>\n<ul>\n<li>一开始执行栈的同步任务执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出 Promise1，同时会生成一个宏任务 setTimeout2</li>\n<li>然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1</li>\n<li>在执行宏任务 setTimeout1 时会生成微任务 Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2</li>\n<li>清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2</li>\n</ul>\n<p>不过这里有一点要注意的，浏览器和 Node 中对于微任务的处理方式有所不同。因为 Node 中的事件循环是跟浏览器完全不是一个东西，是由 libuv 进行实现的。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 32.800000000000004%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABjUlEQVQoz1WRS2/aQBSF+f9St82i6rqtuoqUVi0iAoKdSInUh4CAwTYuYAMF8/ZzZvxljKNKvdIZXWlmvjlzbq0oAL0UZaOllEJK+Z+Elt4kyyQNW3EzFLQ9SM87ROiRb6eIrYc8LqiVB19Zl1pPAubNLgtzQGA8szKHzO/7xNEZIZQGSm76Ca1JwWHlEY2aRLZBarfJ/Z/UwrgCFUpcXJx3O/yRy2m5Zh+sOC7W+mKIFII8V7RdybfnCOOPBi5c4mH9Ak1HDcTsidpXbV+uLTLjDWJwjXy6Iu9+RPU+wI+3MOtUL6IuX76bKOqjXANhv3A4D+qcrCaJ1SAvgW6oQCZk4ZTN1CYPZ7oPSDdz0r86l2hHlUaV4a1T8EWbaLna4dIjGbeIHYPMuUP4v6oMywrnG6aN3yxNi0Br9WDjP4w5Hk6vDivg97Hiupdxqx2eQp/UM0lmj2SeUQHLqZYVBwHrd+8JP30m7NyzaXfY9weIfxMr9MQVk22BtUxxHoekpkHS75L0usiD/kkheQEnvAjBFcdsqAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"浏览器和Node端的差异\"\n        title=\"浏览器和Node端的差异\"\n        src=\"/static/d72f2de7309afe52603e5fc5855725dd/00d43/difference.png\"\n        srcset=\"/static/d72f2de7309afe52603e5fc5855725dd/63868/difference.png 250w,\n/static/d72f2de7309afe52603e5fc5855725dd/0b533/difference.png 500w,\n/static/d72f2de7309afe52603e5fc5855725dd/00d43/difference.png 1000w,\n/static/d72f2de7309afe52603e5fc5855725dd/58fee/difference.png 1051w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<ul>\n<li>浏览器环境下，微任务（Microtask） 的任务队列是每个宏任务（ Macrotask） 执行完之后执行。</li>\n<li>在 Node 中，微任务会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行微任务队列的任务。</li>\n</ul>\n<p>这些知识点在后面整理 Node 的事件循环机制中再作深入整理。</p>\n<h2 id=\"浏览器渲染流程\" style=\"position:relative;\"><a href=\"#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B\" aria-label=\"浏览器渲染流程 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>浏览器渲染流程</h2>\n<p>这一节简单讲讲浏览器拿到数据后的渲染过程，详细内容可以另开一篇讲解。</p>\n<p>浏览器内核拿到内容后，渲染大概可以划分成以下几个步骤：</p>\n<ol>\n<li>解析 HTML 建立 DOM 树</li>\n<li>解析 CSS 构建 Render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 Render 树）</li>\n<li>布局 Render 树（Layout/Reflow），负责各元素尺寸、位置的计算</li>\n<li>绘制 Render 树（Paint），绘制页面像素信息</li>\n<li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上</li>\n</ol>\n<p>所有详细步骤都已经略去，渲染完毕后就是<code>load</code>事件了，之后就是自己的 JS 逻辑处理了。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.2%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAACZklEQVQoz22QXUxScRjGXzg2Z+r6cJWbrXXbZay69cLFWletrVamrljRrHmR5UWtmRV+tdXK9aEp6mrO5ICIHODwJSgfyoQED+cQyUHwHOAw7cYVV+W/v9f1bs/t7/k9L2SzVnkmYyWCjkfwmY7K6LBAJBCCwUG6bJb6fgbnVM+rUfl+ALCE1gnLckZuX8kB/VUA81Ia/rl0mgIMBJ/zGQwbF8HFSGBwskDbhUpqJtNnNmQ6n980EjqKBedqAZyxAnjYLXDHN0GhUPwX2ICBTUH308ox8/JxRzTfYphnTyBsORmznyM5T5NFClQZPal99qh4F+d8IFXChiKBLYn6a1rYyFJyMWcnOM4AUCy65rMbtm/G8auHvrhZtTteRObF9Q6NvvuYe5PZdG/FE/r8TJUv9rtm2pPUTs+ttQ6RNOBinBwomwdAFCwgSS7g+VkAhiErECqBw6OHYdJW3vvuU62y/hJhja3VTnkjnVNzK21vB4J7JzmqRs/NdZv4QEd73+NqW1i4iIHXG5o/lgsbFmW+4FAnk8ZqGBtrB4TYPbsTu168AVXbDdA5GLCF8nUGL6ed9nMT/a/Jo+NBk9JVZEqOwqoOf6piJpB8SYV47dkrmoNp3vRQFGl9Om0+AqnUrJ/jjAnd0IUDE/aoCj8dmfype+r+lsM2MczS+UjCIoTqRnwkPHj/BDi0Dar2VgjyJYjkd+CyWgO/fi5gqRiUSgEAQbA1RmNkA26V6b3sSeeq1Gvy8adHAlO1TonRuKT4rZ7RD2W6FS+4fjCwu0R1/w5EckiW2EbyxttdsPNnSYbQuhyhMPwFLnxqIB2mEjUAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"浏览器渲染流程\"\n        title=\"浏览器渲染流程\"\n        src=\"/static/7a5ffc1fcdcfd71807009601b1178109/1cfc2/renderprocess.png\"\n        srcset=\"/static/7a5ffc1fcdcfd71807009601b1178109/63868/renderprocess.png 250w,\n/static/7a5ffc1fcdcfd71807009601b1178109/0b533/renderprocess.png 500w,\n/static/7a5ffc1fcdcfd71807009601b1178109/1cfc2/renderprocess.png 900w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>这里值得一提的是，在头部引入 CSS 资源的细节：</p>\n<ol>\n<li>CSS 加载过程不会阻塞 DOM 树解析（异步加载时DOM照常构建）</li>\n<li>CSS 解析过程会阻塞 Render 树构建（渲染时需等css加载完毕，因为render树需要css信息）</li>\n</ol>\n<p>另外还有图层合成（composite）的知识点，后面再整理。</p>\n<h2 id=\"事件循环和浏览器渲染之间的联系\" style=\"position:relative;\"><a href=\"#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB\" aria-label=\"事件循环和浏览器渲染之间的联系 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>事件循环和浏览器渲染之间的联系</h2>\n<p>另外值得注意的是并不是每一轮的事件循环都会触发渲染，浏览器是很聪明的，它有可能会合并一些操作，将多次变更一次性渲染上去。</p>\n<p>这里从这篇文章<a href=\"https://juejin.im/entry/6844903476527366151\">从 event loop 规范探究 javaScript 异步及浏览器更新渲染时机 - 前端</a> 中得知一些结论，先放出来供参考，后续有需要作深入研究一下<strong>事件循环和渲染之间的关系</strong>：</p>\n<ul>\n<li>在一轮事件中多次修改同一 DOM，只有最后一次会进行绘制。</li>\n<li>渲染更新（Update the rendering）会在事件循环中的 tasks 完成后进行，但并不是每轮事件循环都会更新渲染，这取决于是否修改了 DOM 和浏览器觉得是否有必要在此时立即将新状态呈现给用户。如果在一帧的时间内（时间并不确定，因为浏览器每秒的帧数总在波动，16.7ms只是估算并不准确）修改了多处DOM，浏览器可能将变动积攒起来，只进行一次绘制，这是合理的。</li>\n<li>如果希望在每轮事件循环都即时呈现变动，可以使用 requestAnimationFrame。</li>\n</ul>\n<h2 id=\"一些代码理解\" style=\"position:relative;\"><a href=\"#%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3\" aria-label=\"一些代码理解 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>一些代码理解</h2>\n<p>这里贴一些奇奇怪怪的关于事件循环的代码，对比浏览器和 Node，以作理解：</p>\n<p>（注意⚠️：以下代码运行在 v11 以下的版本，v11 以上版本已经跟浏览器行为一致）</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// 案例1</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise'</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Node: 1 2 3 promise</span>\n<span class=\"token comment\">// 浏览器: 1 2 promise 3</span>\n\n<span class=\"token comment\">// 案例2</span>\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n  Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'promise'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n\nPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// Node: 2 4 1 3 promise 5</span>\n<span class=\"token comment\">// 浏览器：2 4 1 promise 3 5</span></code></pre></div>\n<h2 id=\"参考\" style=\"position:relative;\"><a href=\"#%E5%8F%82%E8%80%83\" aria-label=\"参考 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>参考</h2>\n<ul>\n<li><a href=\"https://juejin.im/post/5a6547d0f265da3e283a1df7\">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 - 掘金</a></li>\n<li><a href=\"https://juejin.im/post/5be5a0b96fb9a049d518febc\">总结：JavaScript异步、事件循环与消息队列、微任务与宏任务 - 掘金</a></li>\n<li><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\">Tasks, microtasks, queues and schedules - JakeArchibald.com</a></li>\n<li><a href=\"https://blog.csdn.net/Fundebug/article/details/86487117\">浏览器与Node的事件循环(Event Loop)有何区别?<em>Java</em>Fundebug博客-CSDN博客</a></li>\n<li><a href=\"http://lynnelv.github.io/js-event-loop-browser\">深入理解js事件循环机制（浏览器篇） - lynnelv's blog</a></li>\n</ul>","frontmatter":{"title":"浏览器中 JavaScript 单线程运行机制","category":"WebFrontEnd","tags":"Browser 运行原理","date":"2020-04-20","uninqueid":"a9df45bfb68f52299939acc4cf266ebf"}}},"pageContext":{"uninqueid":"a9df45bfb68f52299939acc4cf266ebf"}},"staticQueryHashes":["3649515864"]}